Index: armor_solver/include/armor_solver/gimbal_controller/planner.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#ifndef _PLANNER_HPP_\n#define _PLANNER_HPP_\n\n//\n#include \"armor_solver/armor_solver_common.h\"\n#include \"target_predictor.hpp\"\n#include \"clock/clock.h\"\n#include \"parameter/parameter.h\"\n\n// 3rdparty\n#include \"armor_solver/tinympc/tiny_api.hpp\"\n\n// ros\n#include \"rm_interfaces/msg/target.hpp\"\n\n// Eigen\n#include <Eigen/Dense>\n\nnamespace ckyf {\n    namespace auto_aim {\n        class Planner {\n        public:\n            static constexpr double DT = 0.01;\n            static constexpr int MIN_HALF_HORIZON = 50;\n            static constexpr int MIN_HORIZON = MIN_HALF_HORIZON * 2;\n            static constexpr double G = 9.7833;\n            static constexpr double MAX_PITCH_ACC = 100;\n            static constexpr double MAX_YAW_ACC = 100;\n            using Trajectory = Eigen::Matrix<double, 4, MIN_HORIZON>;\n        public:\n            struct Plan {\n                double yaw;\n                double pitch;\n            };\n        public:\n            Planner();\n            ~Planner();\n            bool init();\n            bool set_target(const rm_interfaces::msg::Target& target);\n            Plan get_plan();\n        private:\n            void setup_yaw_solver();\n            void setup_pitch_solver();\n            void set_solver_horizon(int horizion);\n            void set_yaw_solver_horizon(int horizion);\n            void set_pitch_solver_horizon(int horizion);\n            Trajectory get_trajectory(const double yaw0);\n            std::optional<std::pair<double, double>> trajectory(const double v0, const double d, const double h);\n            std::pair<double, double> aim(const std::tuple<double, double, double>& target_xyz);\n        private:\n            TinySolver* m_yaw_solver;\n            TinySolver* m_pitch_solver;\n            TargetPredictor m_target_predictor;\n            double m_yaw_offset;\n            double m_pitch_offset;\n            double m_bullet_speed;\n            const Eigen::MatrixXd m_A{ {1, DT}, {0, 1} };\n            const Eigen::MatrixXd m_B{ {0}, {DT} };\n            const Eigen::VectorXd m_f{ {0, 0} };\n            Eigen::Matrix<double, 2, 1> m_Q;\n            Eigen::Matrix<double, 1, 1> m_R;\n        };\n    }\n}\n\n#endif // ! _PLANNER_HPP_
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/armor_solver/include/armor_solver/gimbal_controller/planner.hpp b/armor_solver/include/armor_solver/gimbal_controller/planner.hpp
--- a/armor_solver/include/armor_solver/gimbal_controller/planner.hpp	(revision 3e365c7f056e39f3bd2d0f8f7b578e414c34e62b)
+++ b/armor_solver/include/armor_solver/gimbal_controller/planner.hpp	(date 1766836823973)
@@ -31,6 +31,7 @@
             struct Plan {
                 double yaw;
                 double pitch;
+                double origin_yaw;
             };
         public:
             Planner();
@@ -51,6 +52,7 @@
             TinySolver* m_yaw_solver;
             TinySolver* m_pitch_solver;
             TargetPredictor m_target_predictor;
+            double last_azim;
             double m_yaw_offset;
             double m_pitch_offset;
             double m_bullet_speed;
Index: armor_solver/src/gimbal_controller/planner.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"armor_solver/gimbal_controller/planner.hpp\"\n\nnamespace ckyf::auto_aim {\n\n    Planner::Planner() {\n        init();\n    }\n\n    Planner::~Planner() {\n\n    };\n\n    bool Planner::init() {\n        setup_yaw_solver();\n        setup_pitch_solver();\n\n        double Q_0, Q_1, R;\n        global_node::Parameter->get_parameter(\"solver.bullet_speed\", m_bullet_speed);\n        global_node::Parameter->get_parameter(\"planner.plan_Q(0)\", Q_0);\n        global_node::Parameter->get_parameter(\"planner.plan_Q(1)\", Q_1);\n        global_node::Parameter->get_parameter(\"planner.plan_R\", R);\n\n        m_Q << Q_0, Q_1;\n        m_R << R;\n    }\n\n    bool Planner::set_target(const rm_interfaces::msg::Target& target) {\n        return m_target_predictor.set_target(target);\n    }\n\n    void Planner::setup_yaw_solver()\n    {\n        tiny_setup(&m_yaw_solver, m_A, m_B, m_f, m_Q.asDiagonal(), m_R.asDiagonal(), 1.0, 2, 1, MIN_HORIZON, 0);\n\n        m_yaw_solver->settings->max_iter = 10;\n\n        set_yaw_solver_horizon(MIN_HORIZON);\n    }\n\n    void Planner::setup_pitch_solver()\n    {\n        tiny_setup(&m_pitch_solver, m_A, m_B, m_f, m_Q.asDiagonal(), m_R.asDiagonal(), 1.0, 2, 1, MIN_HORIZON, 0);\n\n        m_pitch_solver->settings->max_iter = 10;\n\n        set_pitch_solver_horizon(MIN_HORIZON);\n    }\n\n    void Planner::set_solver_horizon(int horizon) {\n        set_yaw_solver_horizon(horizon);\n        set_pitch_solver_horizon(horizon);\n    }\n\n    void Planner::set_yaw_solver_horizon(int horizion) {\n        horizion = (0 == horizion % 2) ? horizion : horizion + 1;\n        horizion = (horizion > MIN_HORIZON) ? horizion : MIN_HORIZON;\n\n        Eigen::MatrixXd x_min = Eigen::MatrixXd::Constant(2, horizion, -1e17);\n        Eigen::MatrixXd x_max = Eigen::MatrixXd::Constant(2, horizion, 1e17);\n        Eigen::MatrixXd u_min = Eigen::MatrixXd::Constant(1, horizion - 1, -MAX_YAW_ACC);\n        Eigen::MatrixXd u_max = Eigen::MatrixXd::Constant(1, horizion - 1, MAX_YAW_ACC);\n        tiny_set_bound_constraints(m_yaw_solver, x_min, x_max, u_min, u_max);\n    }\n\n    void Planner::set_pitch_solver_horizon(int horizion) {\n        horizion = (0 == horizion % 2) ? horizion : horizion + 1;\n        horizion = (horizion > MIN_HORIZON) ? horizion : MIN_HORIZON;\n\n        Eigen::MatrixXd x_min = Eigen::MatrixXd::Constant(2, horizion, -1e17);\n        Eigen::MatrixXd x_max = Eigen::MatrixXd::Constant(2, horizion, 1e17);\n        Eigen::MatrixXd u_min = Eigen::MatrixXd::Constant(1, horizion - 1, -MAX_PITCH_ACC);\n        Eigen::MatrixXd u_max = Eigen::MatrixXd::Constant(1, horizion - 1, MAX_PITCH_ACC);\n        tiny_set_bound_constraints(m_pitch_solver, x_min, x_max, u_min, u_max);\n    }\n\n    Planner::Plan Planner::get_plan() {\n        // 1. Predict fly_time\n        double dist = m_target_predictor.nearest_armor_dist_2d();\n        auto [target_x, target_y, target_z, target_yaw] = m_target_predictor.target_xyza();\n        //FYT_INFO(\"armor_solver\", \"dist 2d : {:.2f}\", std::sqrt(target_x * target_x + target_y * target_y));\n        auto bullet_traj_opt = trajectory(m_bullet_speed, dist, target_z);\n        if (!bullet_traj_opt.has_value()) {\n            // FYT_ERROR(\"armor_solver\", \"Can't solve bullet\");\n            return {};\n        }\n        auto [bullet_pitch, bullet_fly_time] = *bullet_traj_opt;\n        m_target_predictor.predict(bullet_fly_time);\n        auto armor_xyz = m_target_predictor.nearest_armor_xyz();\n\n        // 2. Get trajectory\n        double yaw0 = 0;\n        Trajectory traj;\n        try {\n            yaw0 = aim(armor_xyz).first;\n            traj = get_trajectory(yaw0);\n        }\n        catch (const std::exception& e) {\n            // FYT_ERROR(\"armor_solver\", \"Unsolvable target {:.2f}\", bullet_speed);\n            return {};\n        }\n\n        // 3. Solve yaw\n        Eigen::VectorXd x0(2);\n        x0 << traj(0, 0), traj(1, 0);\n        tiny_set_x0(m_yaw_solver, x0);\n\n        m_yaw_solver->work->Xref = traj.block(0, 0, 2, MIN_HORIZON);\n        tiny_solve(m_yaw_solver);\n\n        // 4. Solve pitch\n        x0 << traj(2, 0), traj(3, 0);\n        tiny_set_x0(m_pitch_solver, x0);\n\n        m_pitch_solver->work->Xref = traj.block(2, 0, 2, MIN_HORIZON);\n        tiny_solve(m_pitch_solver);\n\n        // plan.target_yaw = limit_rad(traj(0, HALF_HORIZON) + yaw0);\n        // plan.target_pitch = traj(2, HALF_HORIZON);\n        double yaw = limit_rad(m_yaw_solver->work->x(0, MIN_HALF_HORIZON) + yaw0);\n        // std::cout << \"###########################\\n\";\n        // for (int i = 0; i < MIN_HORIZON; i++) {\n        //     std::cout<<traj(0,i)<<\"\\t\"<<m_yaw_solver->work->x(0, i)<<std::endl;\n        // }\n        // plan.yaw_vel = yaw_solver_->work->x(1, HALF_HORIZON);\n        // plan.yaw_acc = yaw_solver_->work->u(0, HALF_HORIZON);\n        double pitch = m_pitch_solver->work->x(0, MIN_HALF_HORIZON);\n        // plan.pitch_vel = pitch_solver_->work->x(1, HALF_HORIZON);\n        // plan.pitch_acc = pitch_solver_->work->u(0, HALF_HORIZON);\n\n        auto shoot_offset_ = 2;\n        // plan.fire =\n        //     std::hypot(\n        //         traj(0, HALF_HORIZON + shoot_offset_) - yaw_solver_->work->x(0, HALF_HORIZON + shoot_offset_),\n        //         traj(2, HALF_HORIZON + shoot_offset_) -\n        //         pitch_solver_->work->x(0, HALF_HORIZON + shoot_offset_)) < (1 / frequency_);\n        Plan plan{\n            .yaw = rad2degree(yaw),\n            .pitch = rad2degree(pitch)\n        };\n        return plan;\n    }\n\n    Planner::Trajectory Planner::get_trajectory(const double yaw0)\n    {\n        Trajectory traj;\n\n        m_target_predictor.predict(-DT * (MIN_HALF_HORIZON + 1));\n        auto armor_xyz = m_target_predictor.nearest_armor_xyz();\n\n        auto [yaw_last, pitch_last] = aim(armor_xyz);\n\n        m_target_predictor.predict(DT);  // [0] = -HALF_HORIZON * DT -> [HHALF_HORIZON] = 0\n        armor_xyz = m_target_predictor.nearest_armor_xyz();\n        auto [yaw, pitch] = aim(armor_xyz);\n\n        for (int i = 0; i < MIN_HORIZON; i++) {\n            m_target_predictor.predict(DT);\n            armor_xyz = m_target_predictor.nearest_armor_xyz();\n            auto [yaw_next, pitch_next] = aim(armor_xyz);\n\n            auto yaw_vel = limit_rad(yaw_next - yaw_last) / (2 * DT);\n            auto pitch_vel = (pitch_next - pitch_last) / (2 * DT);\n\n            traj.col(i) << limit_rad(yaw - yaw0), yaw_vel, pitch, pitch_vel;\n\n            yaw_last = yaw;\n            pitch_last = pitch;\n\n            yaw = yaw_next;\n            pitch = pitch_next;\n        }\n\n        return traj;\n    }\n\n    std::optional<std::pair<double, double>> Planner::trajectory(const double v0, const double d, const double h)\n    {\n        auto a = G * d * d / (2 * v0 * v0);\n        auto b = -d;\n        auto c = a + h;\n        auto delta = b * b - 4 * a * c;\n\n        if (delta < 0) {\n            std::cout << \"d:\" << d << \"v0:\" << v0 << \"h:\" << h << std::endl;\n            return std::nullopt;\n        }\n\n        auto tan_pitch_1 = (-b + std::sqrt(delta)) / (2 * a);\n        auto tan_pitch_2 = (-b - std::sqrt(delta)) / (2 * a);\n        auto pitch_1 = std::atan(tan_pitch_1);\n        auto pitch_2 = std::atan(tan_pitch_2);\n        auto t_1 = d / (v0 * std::cos(pitch_1));\n        auto t_2 = d / (v0 * std::cos(pitch_2));\n\n        double pitch = (t_1 < t_2) ? pitch_1 : pitch_2;\n        double fly_time = (t_1 < t_2) ? t_1 : t_2;\n\n        return std::pair<double, double>{ pitch, fly_time };\n    }\n\n    std::pair<double, double> Planner::aim(const std::tuple<double, double, double>& target_xyz)\n    {\n        auto [x, y, z] = target_xyz;\n        double dist = sqrt(x * x + y * y);\n\n        auto azim = std::atan2(y, x);\n        auto bullet_traj_opt = trajectory(m_bullet_speed, dist, z);\n        if (!bullet_traj_opt.has_value()) throw std::runtime_error(\"Unsolvable bullet trajectory!\");\n\n        auto [bullet_pitch, bullet_fly_time] = *bullet_traj_opt;\n\n        return { limit_rad(azim + m_yaw_offset), -bullet_pitch - m_pitch_offset };\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/armor_solver/src/gimbal_controller/planner.cpp b/armor_solver/src/gimbal_controller/planner.cpp
--- a/armor_solver/src/gimbal_controller/planner.cpp	(revision 3e365c7f056e39f3bd2d0f8f7b578e414c34e62b)
+++ b/armor_solver/src/gimbal_controller/planner.cpp	(date 1766763249777)
@@ -135,7 +135,8 @@
         //         pitch_solver_->work->x(0, HALF_HORIZON + shoot_offset_)) < (1 / frequency_);
         Plan plan{
             .yaw = rad2degree(yaw),
-            .pitch = rad2degree(pitch)
+            .pitch = rad2degree(pitch),
+            .origin_yaw = rad2degree(traj(0,MIN_HALF_HORIZON)+yaw0)
         };
         return plan;
     }
@@ -204,11 +205,14 @@
         double dist = sqrt(x * x + y * y);
 
         auto azim = std::atan2(y, x);
+        if (m_target_predictor.jump) {
+            azim = (azim+last_azim)/2;
+        }
         auto bullet_traj_opt = trajectory(m_bullet_speed, dist, z);
         if (!bullet_traj_opt.has_value()) throw std::runtime_error("Unsolvable bullet trajectory!");
 
         auto [bullet_pitch, bullet_fly_time] = *bullet_traj_opt;
-
+        last_azim = azim;
         return { limit_rad(azim + m_yaw_offset), -bullet_pitch - m_pitch_offset };
     }
 }
\ No newline at end of file
Index: armor_solver/src/gimbal_controller/target_predictor.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"armor_solver/gimbal_controller/target_predictor.hpp\"\n\n#include <iostream>\n\nnamespace ckyf::auto_aim\n{\n    TargetPredictor::TargetPredictor() {\n        m_has_target = false;\n        m_armor_num = 0;\n        m_x = Eigen::VectorXd::Zero(11);\n    }\n\n    TargetPredictor::TargetPredictor(const rm_interfaces::msg::Target& target) {\n        set_target(target);\n    }\n\n    void TargetPredictor::predict(double dt) {\n        m_x[0] += dt * m_x[1]; //  x  += dt * v_x\n        m_x[2] += dt * m_x[3]; //  y  += dt * v_x\n        m_x[4] += dt * m_x[5]; //  z  += dt * v_x\n        m_x[6] += dt * m_x[7]; // yaw += dt * v_yaw\n        m_x[6] = limit_rad(m_x[6]);\n    }\n\n    std::tuple<double, double, double> TargetPredictor::target_xyz() const {\n        return { m_x[0], m_x[2], m_x[4] };\n    }\n\n    std::tuple<double, double, double, double> TargetPredictor::target_xyza() const {\n        return { m_x[0], m_x[2], m_x[4], m_x[6] };\n    }\n\n    double TargetPredictor::target_dist_2d() const {\n        return square_sum_sqrt(m_x[0], m_x[2]);\n    }\n\n    double TargetPredictor::target_dist_3d() const {\n        return square_sum_sqrt(m_x[0], m_x[2], m_x[4]);\n    }\n\n    double TargetPredictor::nearest_armor_dist_2d() const {\n        auto [x, y, z] = nearest_armor_xyz();\n        return square_sum_sqrt(x, y);\n    }\n\n    double TargetPredictor::nearest_armor_dist_3d() const {\n        auto [x, y, z] = nearest_armor_xyz();\n        return square_sum_sqrt(x, y, z);\n    }\n\n    bool TargetPredictor::set_target(const rm_interfaces::msg::Target& target) {\n        try {\n            double x = target.position.x;\n            double y = target.position.y;\n            double z = target.position.z;\n\n            double v_x = target.velocity.x;\n            double v_y = target.velocity.y;\n            double v_z = target.velocity.z;\n\n            double yaw = target.yaw;\n\n            double v_yaw = target.v_yaw;\n\n            double radius = target.radius_2;\n\n            m_armor_num = static_cast<size_t>(target.armors_num);\n\n            double l = target.radius_2 - target.radius_1;\n            double h = target.d_height;\n\n            // x vx y vy z vz a w r l h\n            // a: angle\n            // w: angular velocity\n            // l: r2 - r1\n            // h: z2 - z1\n            Eigen::VectorXd X0{ {x, v_x, y, v_y, z, v_z, yaw, v_yaw, radius, l, h} };  //初始化预测量\n            m_x = X0;\n\n            m_has_target = true;\n        }\n        catch (const std::exception& e) {\n            std::cerr << e.what() << std::endl;\n            return false;\n        }\n\n        return true;\n    }\n\n    std::tuple<double, double, double, double> TargetPredictor::cal_armor_xyza(const size_t idx) const {\n        if (0 > m_armor_num) throw std::invalid_argument(\"armor_num is zero!\");\n        double yaw = limit_rad(m_x[6] + idx * 2 * PI / m_armor_num);\n        int use_l_h = (m_armor_num == 4) && (idx == 1 || idx == 3);\n\n        double r = (use_l_h) ? m_x[8] + m_x[9] : m_x[8];\n        double x = m_x[0] - r * std::cos(yaw);\n        double y = m_x[2] - r * std::sin(yaw);\n        double z = (use_l_h) ? m_x[4] + m_x[10] : m_x[4];\n        return { x, y, z, yaw };\n    }\n\n    // 计算出装甲板中心的坐标（考虑长短轴）\n    std::tuple<double, double, double> TargetPredictor::cal_armor_xyz(const size_t idx) const {\n        auto [x, y, z, yaw] = cal_armor_xyza(idx);\n        return { x,y,z };\n    }\n\n    std::tuple<double, double, double, double> TargetPredictor::nearest_armor_xyza() const {\n        double x, y, z, yaw;\n        double min_dist = std::numeric_limits<double>::max();\n        for (size_t i = 0; i < m_armor_num; ++i) {\n            auto [temp_x, temp_y, temp_z, temp_yaw] = cal_armor_xyza(i);\n            double temp_dist = square_sum_sqrt(temp_x, temp_y, temp_z);\n            if (temp_dist < min_dist) {\n                x = temp_x;\n                y = temp_y;\n                z = temp_z;\n                yaw = temp_yaw;\n                min_dist = temp_dist;\n            }\n        }\n        return { x,y,z,yaw };\n    }\n\n    std::tuple<double, double, double> TargetPredictor::nearest_armor_xyz() const {\n        auto [x, y, z, yaw] = nearest_armor_xyza();\n        return { x,y,z };\n    }\n\n    bool TargetPredictor::has_target() const {\n        return m_has_target;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/armor_solver/src/gimbal_controller/target_predictor.cpp b/armor_solver/src/gimbal_controller/target_predictor.cpp
--- a/armor_solver/src/gimbal_controller/target_predictor.cpp	(revision 3e365c7f056e39f3bd2d0f8f7b578e414c34e62b)
+++ b/armor_solver/src/gimbal_controller/target_predictor.cpp	(date 1766763343649)
@@ -2,6 +2,8 @@
 
 #include <iostream>
 
+#include "armor_solver/kalman_pool/common.h"
+
 namespace ckyf::auto_aim
 {
     TargetPredictor::TargetPredictor() {
@@ -38,12 +40,12 @@
         return square_sum_sqrt(m_x[0], m_x[2], m_x[4]);
     }
 
-    double TargetPredictor::nearest_armor_dist_2d() const {
+    double TargetPredictor::nearest_armor_dist_2d()  {
         auto [x, y, z] = nearest_armor_xyz();
         return square_sum_sqrt(x, y);
     }
 
-    double TargetPredictor::nearest_armor_dist_3d() const {
+    double TargetPredictor::nearest_armor_dist_3d()  {
         auto [x, y, z] = nearest_armor_xyz();
         return square_sum_sqrt(x, y, z);
     }
@@ -105,10 +107,13 @@
         return { x,y,z };
     }
 
-    std::tuple<double, double, double, double> TargetPredictor::nearest_armor_xyza() const {
+    std::tuple<double, double, double, double> TargetPredictor::nearest_armor_xyza()  {
         double x, y, z, yaw;
         double min_dist = std::numeric_limits<double>::max();
+
+        std::vector<std::tuple<double,double,double,double>> _yaw;
         for (size_t i = 0; i < m_armor_num; ++i) {
+            _yaw.push_back(cal_armor_xyza(i));
             auto [temp_x, temp_y, temp_z, temp_yaw] = cal_armor_xyza(i);
             double temp_dist = square_sum_sqrt(temp_x, temp_y, temp_z);
             if (temp_dist < min_dist) {
@@ -119,10 +124,28 @@
                 min_dist = temp_dist;
             }
         }
+
+        std::sort(_yaw.begin(), _yaw.end(),[](auto a,auto b) {
+            auto [a_x,a_y,a_z,a_yaw] = a;
+            auto [b_x,b_y,b_z,b_yaw] = b;
+            return square_sum_sqrt(a_x, a_y, a_z) < square_sum_sqrt(b_x, b_y, b_z);
+        });
+
+        auto [x1,y1,z1,yaw1] = _yaw[0];
+        auto [x2,y2,z2,yaw2] = _yaw[1];
+        if (std::abs(square_sum_sqrt(x1,y1,z1)-square_sum_sqrt(x2,y2,z2))>0.5) {
+            // yaw=(yaw1+yaw2)/2;
+            // x=(x1+x2)/2;
+            // y=(y1+y1)/2;
+            // z=(z1+z2)/2;
+            //std::cout<< yaw1*180/M_PI<<"\t"<<yaw2*180/M_PI<<std::endl;
+            jump = true;
+        }
+
         return { x,y,z,yaw };
     }
 
-    std::tuple<double, double, double> TargetPredictor::nearest_armor_xyz() const {
+    std::tuple<double, double, double> TargetPredictor::nearest_armor_xyz()  {
         auto [x, y, z, yaw] = nearest_armor_xyza();
         return { x,y,z };
     }
Index: armor_solver/include/armor_solver/gimbal_controller/target_predictor.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#ifndef _TARGET_PREDICTOR_HPP_\n#define _TARGET_PREDICTOR_HPP_\n\n//\n#include \"armor_solver/armor_solver_common.h\"\n\n// std\n#include <tuple>\n#include <numeric>\n\n// ros\n#include <rm_interfaces/msg/target.hpp>\n\n// Eigen\n#include <Eigen/Dense>\n\nnamespace ckyf\n{\n    namespace auto_aim\n    {\n        template <typename... _Args, typename = typename std::enable_if_t<(std::is_arithmetic_v<_Args> && ...)>>\n        auto square_sum(const _Args... args) {\n            return ((args * args) + ...);\n        }\n        template <typename... _Args, typename = typename std::enable_if_t<(std::is_arithmetic_v<_Args> && ...)>>\n        auto square_sum_sqrt(const _Args... args) {\n            return std::sqrt(square_sum(args...));\n        }\n\n        class TargetPredictor {\n        public:\n            TargetPredictor();\n            TargetPredictor(const rm_interfaces::msg::Target& target);\n            void predict(double dt);\n            double target_dist_2d() const;\n            double target_dist_3d() const;\n            double nearest_armor_dist_2d() const;\n            double nearest_armor_dist_3d() const;\n            std::tuple<double, double, double> target_xyz() const;\n            std::tuple<double, double, double, double> target_xyza() const;\n            std::tuple<double, double, double> nearest_armor_xyz() const;\n            std::tuple<double, double, double, double> nearest_armor_xyza() const;\n            bool set_target(const rm_interfaces::msg::Target& target);\n            bool has_target() const;\n            ~TargetPredictor() = default;\n        private:\n            std::tuple<double, double, double> cal_armor_xyz(const size_t idx) const;\n            std::tuple<double, double, double, double> cal_armor_xyza(const size_t idx) const;\n        private:\n            size_t m_armor_num;\n            bool m_has_target;\n            Eigen::VectorXd m_x;\n        };\n    }\n}\n\n#endif // ! _TARGET_PREDICTOR_HPP_
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/armor_solver/include/armor_solver/gimbal_controller/target_predictor.hpp b/armor_solver/include/armor_solver/gimbal_controller/target_predictor.hpp
--- a/armor_solver/include/armor_solver/gimbal_controller/target_predictor.hpp	(revision 3e365c7f056e39f3bd2d0f8f7b578e414c34e62b)
+++ b/armor_solver/include/armor_solver/gimbal_controller/target_predictor.hpp	(date 1766763343662)
@@ -34,15 +34,16 @@
             void predict(double dt);
             double target_dist_2d() const;
             double target_dist_3d() const;
-            double nearest_armor_dist_2d() const;
-            double nearest_armor_dist_3d() const;
+            double nearest_armor_dist_2d() ;
+            double nearest_armor_dist_3d() ;
             std::tuple<double, double, double> target_xyz() const;
             std::tuple<double, double, double, double> target_xyza() const;
-            std::tuple<double, double, double> nearest_armor_xyz() const;
-            std::tuple<double, double, double, double> nearest_armor_xyza() const;
+            std::tuple<double, double, double> nearest_armor_xyz() ;
+            std::tuple<double, double, double, double> nearest_armor_xyza() ;
             bool set_target(const rm_interfaces::msg::Target& target);
             bool has_target() const;
             ~TargetPredictor() = default;
+            bool jump = false;
         private:
             std::tuple<double, double, double> cal_armor_xyz(const size_t idx) const;
             std::tuple<double, double, double, double> cal_armor_xyza(const size_t idx) const;
