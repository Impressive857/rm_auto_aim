Index: armor_solver/src/gimbal_controller/controller.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by lbw on 25-3-13.\n//\n\n#include <armor_solver/gimbal_controller/controller.h>\n#include \"visualization/visualization.h\"\n#include <parameter/parameter.h>\n#include <clock/clock.h>\n\n#include <data_center/data_recorder.h>\n#include <spdlog/common.h>\nusing namespace std::chrono_literals;\n\nnamespace ckyf::auto_aim\n{\n    Controller::Controller() : state()\n    {\n        tf2_buffer_ = std::make_unique<tf2_ros::Buffer>(global_node::Clock->get_clock());\n        tf2_listener_ = std::make_unique<tf2_ros::TransformListener>(*tf2_buffer_);\n        adviser_ = TargetAdviser::getInstance();\n\n        init();\n    }\n\n    void Controller::init()\n    {\n        std::string compenstator_type;\n        global_node::Parameter->get_parameter(\"solver.compensator_type\", compenstator_type);\n        if (trajectory_compensator_ == nullptr)\n            trajectory_compensator_ = fyt::CompensatorFactory::createCompensator(compenstator_type);\n        global_node::Parameter->get_parameter(\"solver.iteration_times\", trajectory_compensator_->iteration_times);\n        global_node::Parameter->get_parameter(\"solver.bullet_speed\", trajectory_compensator_->velocity);\n        global_node::Parameter->get_parameter(\"solver.gravity\", trajectory_compensator_->gravity);\n        global_node::Parameter->get_parameter(\"solver.resistance\", trajectory_compensator_->resistance);\n        global_node::Parameter->get_parameter(\"target_frame\", target_frame_);\n        global_node::Parameter->get_parameter(\"solver.side_angle\", side_angle_);\n        global_node::Parameter->get_parameter(\"solver.shoot_frequency\", frequency_);\n        global_node::Parameter->get_parameter(\"solver.wild_coefficient\", wild_coefficient_);\n        trajectory_compensator_->iteration_times = 20;\n        trajectory_compensator_->velocity = 22;\n        trajectory_compensator_->gravity = 9.8;\n        trajectory_compensator_->resistance = 0.001;\n        if (manual_compensator_ == nullptr)\n            manual_compensator_ = std::make_unique<fyt::ManualCompensator>();\n        state = TRACKING_ARMOR;\n        overflow_count_ = 0;\n\n        m_planner.init();\n    }\n\n\n    void Controller::setOffset(const Offset& offset)\n    {\n        offset_ = offset;\n        manual_compensator_->updateMapFlow(offset_.angle_str);\n    }\n\n    void Controller::transCmd()\n    {\n        target_id = adviser_->getShootTarget();\n\n        global_node::Visualization->debug_target(target_id + \" [Invalid]\");\n        if (!kalman_pool_->isExist(target_id) && target_id != NoTarget)\n        {\n            sigma_vx_.reset();\n            sigma_vy_.reset();\n            return;\n        }\n\n        if (target_id == NoTarget ||\n            (kalman_pool_->getTrackState(target_id) != KalmanCommon::Detect_Tracking &&\n                kalman_pool_->getTrackState(target_id) != KalmanCommon::Detect_Temp_Lost &&\n                kalman_pool_->getTrackState(target_id) != KalmanCommon::Sensing_Detecting))\n        {\n            rm_interfaces::msg::GimbalCmd gimbal_cmd;\n            gimbal_cmd.id = -1;\n            gimbal_cmd.pitch = 0;\n            gimbal_cmd.yaw = 0;\n            sigma_vx_.reset();\n            sigma_vy_.reset();\n            publish_GimbalCmd_(gimbal_cmd);\n            return;\n        }\n\n        target_ = kalman_pool_->predict(target_id);\n        m_planner.set_target(target_);\n        target_.header.frame_id = target_frame_;\n        target_.header.stamp = global_node::Clock->time();\n        //发送target和measurement\n        publish_target_(target_);\n        kalman_pool_->measurements[target_.id].header = target_.header;\n        publish_measurement_(kalman_pool_->measurements[target_.id]);\n        global_node::Visualization->debug_target(target_id + \" [Shoot]\");\n        global_node::Visualization->debug_target_marker(target_);\n        //tf变换\n        try\n        {\n            //获取云台当前的RPY\n            auto gimbal_tf =\n                tf2_buffer_->lookupTransform(\"odom\", \"gimbal_link\", tf2::TimePointZero);\n            auto msg_q = gimbal_tf.transform.rotation;\n\n            tf2::Quaternion tf_q;\n            tf2::fromMsg(msg_q, tf_q);\n            tf2::Matrix3x3(tf_q).getRPY(rpy_[0], rpy_[1], rpy_[2]);\n            rpy_[1] = -rpy_[1];\n\n            //target的变换\n            geometry_msgs::msg::PoseStamped ps;\n            ps.header = target_.header;\n            ps.pose.position = target_.position;\n            try\n            {\n                target_.position = tf2_buffer_->transform(ps, \"odom\").pose.position;\n            }\n            catch (const tf2::TransformException& ex)\n            {\n                FYT_ERROR(\"armor_solver\", \"Transform Error: {}\", ex.what());\n            }\n        }\n        catch (tf2::TransformException& ex)\n        {\n            FYT_ERROR(\"armor_solver\", \"{}\", ex.what());\n            return;\n        }\n\n        //大致估计弹道后的装机板位置以及yaw转动速度\n        Eigen::Vector<double, 3> target_pos;\n        target_pos << target_.position.x, target_.position.y, target_.position.z;\n        double fly_time = trajectory_compensator_->getFlyingTime(target_pos);\n\n        rclcpp::Time now_time = timer_();\n        rclcpp::Time img_time = target_.header.stamp;\n        rclcpp::Duration duration = now_time - img_time;\n        double delay = duration.seconds() + delay_.prediction_delay; //算法\n        delay += fly_time; //飞行时间\n\n\n        vx = target_.velocity.x;\n        vy = target_.velocity.y;\n        vz = target_.velocity.z;\n        v_yaw = target_.v_yaw;\n\n\n        //计算速度样本方差（无偏）\n        sigma_vx_.push(vx);\n        sigma_vy_.push(vy);\n        global_node::Visualization->debug_user.sigma_vx = sigma_vx_.getSigma();\n        global_node::Visualization->debug_user.sigma_vy = sigma_vy_.getSigma();\n\n        //静止噪声抑制\n        if (std::abs(vx) < 0.5 && v_yaw > 5.0)vx = 0;\n        if (std::abs(vy) < 0.5 && v_yaw > 5.0)vy = 0;\n        vz = 0;\n\n        double target_yaw = target_.yaw + v_yaw * delay;\n        double delay_tr = delay + delay_.response_delay;\n\n\n        target_pos.x() += vx * delay_tr + 0.5 * delay_tr * delay_tr * target_.acceleration.x;\n        target_pos.y() += vy * delay_tr + 0.5 * delay_tr * delay_tr * target_.acceleration.y;\n        target_pos.z() += vz * delay_tr + 0.5 * delay_tr * delay_tr * target_.acceleration.z;\n\n        global_node::Visualization->debug_user.debug16 = vy * delay_tr + 0.5 * delay_tr * delay_tr * target_.\n            acceleration.y;\n\n        // real-Armor-position\n        auto real_armor_position = getBestArmorPositions2(\n            target_pos, target_yaw,\n            target_.radius_1, target_.radius_2,\n            target_.d_height,\n            target_.armors_num,\n            delay_.control_delay);\n        double distance = real_armor_position.norm();\n\n        // Calculate real_yaw, real_pitch\n        double real_yaw, real_pitch;\n        calcYawAndPitch(real_armor_position, real_yaw, real_pitch);\n\n        // Choose the best armor to shoot\n        Eigen::Vector3d v_vec(vx, vy, 0);\n        double pre_offset = delay_.command_delay;\n\n        auto cmd_armor_position = getBestArmorPositions2(\n            target_pos + v_vec * pre_offset, target_yaw,\n            target_.radius_1, target_.radius_2,\n            target_.d_height,\n            target_.armors_num,\n            delay_.control_delay);\n\n        // Calculate cmd_yaw, cmd_pitch\n        double cmd_yaw, cmd_pitch;\n        calcYawAndPitch(cmd_armor_position, cmd_yaw, cmd_pitch);\n\n        // Initialize gimbal_cmd\n        rm_interfaces::msg::GimbalCmd gimbal_cmd;\n        gimbal_cmd.header = target_.header;\n        top_freq_ = 4 * 0.5 * v_yaw / M_PI;\n\n        //计算中心yaw\n        double center_yaw, center_pitch;\n        calcYawAndPitch(target_pos, center_yaw, center_pitch);\n\n\n        gimbal_cmd.distance = distance;\n        top_ampl_ = 2 * atan2(r, sqrt(target_pos.x() * target_pos.x() + target_pos.y() * target_pos.y()));\n\n        // Compensate angle by angle_offset_map\n        auto angle_offset = manual_compensator_->angleHardCorrect(target_pos.head(2).norm(), target_pos.z());\n\n        double pitch_offset = angle_offset[0] * M_PI / 180;\n        double yaw_offset = angle_offset[1] * M_PI / 180;\n\n        cmd_pitch = cmd_pitch + pitch_offset;\n        cmd_yaw = angles::normalize_angle(cmd_yaw + yaw_offset);\n\n        real_pitch = real_pitch + pitch_offset;\n        real_yaw = angles::normalize_angle(real_yaw + yaw_offset);\n\n        center_pitch = center_pitch + pitch_offset;\n        center_yaw = angles::normalize_angle(center_yaw + yaw_offset);\n        double bounder_yaw = center_yaw + 0.5 * top_ampl_;\n        jump_time_ = std::abs(bounder_yaw - rpy_[2]) * top_freq_;\n\n\n        //debug\n        visualization::Offset offset{};\n        offset.distance = target_pos.head(2).norm();\n        offset.height = target_pos.z();\n        offset.pitch_offset = angle_offset[0];\n        offset.yaw_offset = angle_offset[1];\n        global_node::Visualization->debug_offset(offset);\n\n        gimbal_cmd.fire_advice = isOnTarget(rpy_[2], rpy_[1], real_yaw, real_pitch, distance);\n        switch (state)\n        {\n        case TRACKING_ARMOR:\n        {\n            if (std::abs(v_yaw) > threshold_.max_tracking_v_yaw)\n            {\n                overflow_count_++;\n            }\n            else\n            {\n                overflow_count_ = std::max(0, overflow_count_ - 1);\n            }\n\n            if (overflow_count_ > threshold_.transfer_thresh)\n            {\n                state = TRACKING_CENTER;\n            }\n            global_node::Visualization->debug_tracking_mode(\n                std::string(\"tracking_armor\") + \" [\" +\n                std::to_string(v_yaw) + \"]\");\n            break;\n        }\n        case TRACKING_CENTER:\n        {\n            if (std::abs(v_yaw) < threshold_.min_switching_v_yaw)\n            {\n                overflow_count_++;\n            }\n            else\n            {\n                overflow_count_ = std::max(0, overflow_count_ - 1);\n            }\n\n            if (overflow_count_ > threshold_.transfer_thresh)\n            {\n                state = TRACKING_ARMOR;\n                overflow_count_ = 0;\n            }\n\n            double temp_yaw, temp_pitch;\n\n            //计算yaw 不添加多余delay\n            calcYawAndPitch(target_pos, cmd_yaw, temp_pitch);\n\n            //计算pitch 添加controller_delay\n            cmd_armor_position = getBestArmorPositions2(target_pos, target_yaw,\n                target_.radius_1, target_.radius_2,\n                target_.d_height,\n                target_.armors_num, delay_.control_delay);\n            calcYawAndPitch(cmd_armor_position, temp_yaw, cmd_pitch);\n\n            //依据角度的cos值判定\n            Eigen::Vector3d target_pos_tracking_center;\n            double target_yaw_tracking_center;\n            target_pos_tracking_center.x() = target_pos.x() + vx * delay_.trigger_delay;\n            target_pos_tracking_center.y() = target_pos.y() + vy * delay_.trigger_delay;\n            target_pos_tracking_center.z() = target_pos.z() + vz * delay_.trigger_delay;\n            target_yaw_tracking_center = target_yaw + v_yaw * delay_.trigger_delay;\n            getBestArmorPositions2(\n                target_pos_tracking_center, target_yaw_tracking_center,\n                target_.radius_1, target_.radius_2,\n                target_.d_height,\n                target_.armors_num, delay_.trigger_delay);\n            double shoot_angle_window = threshold_.shooting_threshold / (target_.radius_1 + 0.0001);\n            if (cosTheta_ > cos(shoot_angle_window))\n            {\n                double shoot_time_window = shoot_angle_window / v_yaw;\n                int shoot_frequency = (int)(wild_coefficient_ * shoot_time_window / (1 / frequency_));\n                gimbal_cmd.fire_advice = shoot_frequency < 1 ? 1 : shoot_frequency;\n                gimbal_cmd.fire_advice *= 10;\n                if (gimbal_cmd.fire_advice > 20)\n                    gimbal_cmd.fire_advice = 20;\n            }\n            else\n                gimbal_cmd.fire_advice = 0;\n            global_node::Visualization->debug_user.debug17 = cosTheta_;\n            global_node::Visualization->debug_tracking_mode(\n                std::string(\"tracking_center\") + \" [\" +\n                std::to_string(v_yaw) + \"]\");\n            break;\n        }\n        }\n\n        gimbal_cmd.yaw = cmd_yaw * 180 / M_PI;\n        gimbal_cmd.pitch = cmd_pitch * 180 / M_PI;\n\n        Planner::Plan plan = m_planner.get_plan();\n        //gimbal_cmd.yaw = plan.yaw;\n        gimbal_cmd.tj_yaw = plan.yaw;\n        gimbal_cmd.yaw_diff = (cmd_yaw - rpy_[2]) * 180 / M_PI;\n        gimbal_cmd.pitch_diff = (cmd_pitch - rpy_[1]) * 180 / M_PI;\n        real_yaw = real_yaw * 180.0 / M_PI;\n        real_pitch = -real_pitch * 180.0 / M_PI;\n        global_node::Visualization->debug_user.real_pitch = real_pitch;\n        global_node::Visualization->debug_user.real_yaw = real_yaw;\n        global_node::Visualization->debug_user.position_diff = target_.position_diff;\n        if (target_.id == \"1\")\n        {\n            gimbal_cmd.id = 1;\n        }\n        else if (target_.id == \"2\")\n        {\n            gimbal_cmd.id = 2;\n        }\n        else if (target_.id == \"3\")\n        {\n            gimbal_cmd.id = 3;\n        }\n        else if (target_.id == \"4\")\n        {\n            gimbal_cmd.id = 4;\n        }\n        else if (target_.id == \"5\")\n        {\n            gimbal_cmd.id = 5;\n        }\n        else if (target_.id == \"sentry\")\n        {\n            gimbal_cmd.id = 6;\n        }\n        else if (target_.id == \"outpost\")\n        {\n            gimbal_cmd.id = 7;\n        }\n        else if (target_.id == \"base\")\n        {\n            gimbal_cmd.id = 8;\n        }\n        else\n        {\n            gimbal_cmd.id = 0;\n        }\n\n\n        Eigen::Matrix2d R;\n        R << std::cos(rpy_[2]), std::sin(rpy_[2]),\n            -std::sin(rpy_[2]), std::cos(rpy_[2]);\n        Eigen::Vector2d target_velocity_2d;\n        target_velocity_2d << vx, vy;\n        Eigen::Vector2d target_linear_velocity_2d;\n        target_linear_velocity_2d << v_yaw * r * cos(target_yaw), v_yaw* r* sin(target_yaw);\n\n        Eigen::Vector2d tangental_velocity_2d = R * (target_velocity_2d + target_linear_velocity_2d);\n        double feed_forward_w_radius = -tangental_velocity_2d(1) / distance;\n        double feed_forward_w_angle = feed_forward_w_radius * 180 / M_PI;\n        gimbal_cmd.top_freq = feed_forward_w_angle; //前馈\n        gimbal_cmd.shoot_freq = 20;\n\n        //电控前馈处理\n        gimbal_cmd.top_ampl = top_ampl_;\n        if (\n            std::abs(gimbal_cmd.yaw - last_cmd_yaw_) > 2 ||\n            (gimbal_cmd.jump_time < 5 && gimbal_cmd.jump_time > 0)) //防止丢包，连续发送5帧\n        {\n            gimbal_cmd.jump_time += 1;\n        }\n        else\n        {\n            gimbal_cmd.jump_time = 0;\n        }\n        last_cmd_yaw_ = gimbal_cmd.yaw;\n        publish_GimbalCmd_(gimbal_cmd);\n\n        global_node::Visualization->debug_shoot_marker(gimbal_cmd.pitch, gimbal_cmd.yaw);\n    }\n\n    bool Controller::isOnTarget(const double cur_yaw,\n        const double cur_pitch,\n        const double target_yaw,\n        const double target_pitch,\n        const double distance) const noexcept\n    {\n        // Judge whether to shoot\n        //double v_coff = std::abs(v_yaw) * 0.01 + 1;\n        double shooting_range_yaw = std::abs(atan2(threshold_.shooting_range_w / 2, distance));\n        double shooting_range_pitch = std::abs(atan2(threshold_.shooting_range_h / 2, distance));\n        if (target_.id == \"1\" || target_.id == \"base\")\n        {\n            shooting_range_yaw = std::abs(atan2(threshold_.shooting_range_large_w / 2, distance));\n            shooting_range_pitch = std::abs(atan2(threshold_.shooting_range_large_h / 2, distance));\n        }\n\n        // Limit the shooting area to 1 degree to avoid not shooting when distance is\n        // too large\n        shooting_range_yaw = std::max(shooting_range_yaw, 1.0 * M_PI / 180);\n        shooting_range_pitch = std::max(shooting_range_pitch, 1.0 * M_PI / 180);\n        if (std::abs(cur_yaw - target_yaw) < shooting_range_yaw &&\n            std::abs(cur_pitch - target_pitch) < shooting_range_pitch)\n        {\n            return true;\n        }\n        return false;\n    }\n\n    void Controller::calcYawAndPitch(const Eigen::Vector3d& p,\n        double& yaw,\n        double& pitch) const noexcept\n    {\n        // Calculate yaw and pitch\n        yaw = atan2(p.y(), p.x());\n        pitch = atan2(p.z(), p.head(2).norm());\n        if (double temp_pitch = pitch; trajectory_compensator_->compensate(p, temp_pitch))\n        {\n            pitch = temp_pitch;\n        }\n    }\n\n    Eigen::Vector3d Controller::getBestArmorPositions2(const Eigen::Vector3d& target_center_without_delay,\n        double target_yaw_without_delay,\n        double r1,\n        double r2,\n        double d_height,\n        size_t armors_num,\n        double controller_delay) noexcept\n    {\n        Eigen::Vector3d v(vx, vy, vz);\n        Eigen::Vector3d a(target_.acceleration.x, target_.acceleration.y, target_.acceleration.z);\n        Eigen::Vector3d target_center_with_delay = target_center_without_delay\n            + v * controller_delay + 0.5 * controller_delay * controller_delay * a;\n        double target_yaw_with_delay = target_yaw_without_delay + v_yaw * controller_delay;\n\n        int i = getArmorIdWithDelay(target_center_with_delay, target_yaw_with_delay, r1, r2, d_height, armors_num);\n\n        r = 0;\n        double target_dz = 0.;\n        double temp_yaw = target_yaw_without_delay + i * (2 * M_PI / armors_num);\n        if (armors_num == 4)\n        {\n            bool is_current_pair = i % 2 == 0;\n            r = is_current_pair ? r1 : r2;\n            target_dz = is_current_pair ? 0 : d_height;\n        }\n        else\n        {\n            r = r1;\n            target_dz = 0;\n        }\n\n        return target_center_without_delay + Eigen::Vector3d(-r * cos(temp_yaw), -r * sin(temp_yaw), target_dz);\n    }\n\n    int Controller::getArmorIdWithDelay(const Eigen::Vector3d& target_center, double target_yaw, double r1, double r2,\n        double d_height, size_t armors_num) noexcept\n    {\n        auto armor_positions = std::vector<Eigen::Vector3d>(armors_num, Eigen::Vector3d::Zero());\n        auto armors_vec = std::vector<Eigen::Vector2d>(armors_num, Eigen::Vector2d::Zero());\n        // Calculate the position of each armor\n        bool is_current_pair = true;\n        double r = 0., target_dz = 0.;\n        for (size_t i = 0; i < armors_num; i++)\n        {\n            double temp_yaw = target_yaw + i * (2 * M_PI / armors_num);\n            if (armors_num == 4)\n            {\n                r = is_current_pair ? r1 : r2;\n                target_dz = is_current_pair ? 0 : d_height;\n                is_current_pair = !is_current_pair;\n            }\n            else\n            {\n                r = r1;\n                target_dz = 0;\n            }\n            armor_positions[i] =\n                target_center + Eigen::Vector3d(-r * cos(temp_yaw), -r * sin(temp_yaw), target_dz);\n            Eigen::Vector2d armor_vec;\n            armor_vec << armor_positions[i](0) - target_center(0), armor_positions[i](1) - target_center(1);\n            armors_vec[i] = armor_vec;\n        }\n\n        Eigen::Vector2d center_vec;\n        center_vec << -target_center(0), -target_center(1);\n        double maxcosTheta = -2.0;\n        double argmax = 0;\n        for (int i = 0; i < armors_num; i++)\n        {\n            double cosTheta = center_vec.dot(armors_vec[i]) / center_vec.norm() / armors_vec[i].norm();\n            if (cosTheta > maxcosTheta)\n            {\n                argmax = i;\n                maxcosTheta = cosTheta;\n            }\n        }\n\n        global_node::Visualization->debug_user.max_costheta = maxcosTheta;\n        cosTheta_ = maxcosTheta;\n        return argmax;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/armor_solver/src/gimbal_controller/controller.cpp b/armor_solver/src/gimbal_controller/controller.cpp
--- a/armor_solver/src/gimbal_controller/controller.cpp	(revision 3e365c7f056e39f3bd2d0f8f7b578e414c34e62b)
+++ b/armor_solver/src/gimbal_controller/controller.cpp	(date 1766755935363)
@@ -87,7 +87,9 @@
         target_.header.frame_id = target_frame_;
         target_.header.stamp = global_node::Clock->time();
         //发送target和measurement
+        target_.v_yaw*=180/M_PI;
         publish_target_(target_);
+        target_.v_yaw/=180/M_PI;
         kalman_pool_->measurements[target_.id].header = target_.header;
         publish_measurement_(kalman_pool_->measurements[target_.id]);
         global_node::Visualization->debug_target(target_id + " [Shoot]");
@@ -315,11 +317,11 @@
         }
         }
 
-        gimbal_cmd.yaw = cmd_yaw * 180 / M_PI;
+        //gimbal_cmd.yaw = cmd_yaw * 180 / M_PI;
         gimbal_cmd.pitch = cmd_pitch * 180 / M_PI;
 
         Planner::Plan plan = m_planner.get_plan();
-        //gimbal_cmd.yaw = plan.yaw;
+        gimbal_cmd.yaw = plan.origin_yaw;
         gimbal_cmd.tj_yaw = plan.yaw;
         gimbal_cmd.yaw_diff = (cmd_yaw - rpy_[2]) * 180 / M_PI;
         gimbal_cmd.pitch_diff = (cmd_pitch - rpy_[1]) * 180 / M_PI;
@@ -356,23 +358,20 @@
         {
             gimbal_cmd.id = 7;
         }
-        else if (target_.id == "base")
-        {
+        else if (target_.id == "base") {
             gimbal_cmd.id = 8;
-        }
-        else
-        {
+        } else {
             gimbal_cmd.id = 0;
         }
 
 
         Eigen::Matrix2d R;
         R << std::cos(rpy_[2]), std::sin(rpy_[2]),
-            -std::sin(rpy_[2]), std::cos(rpy_[2]);
+                -std::sin(rpy_[2]), std::cos(rpy_[2]);
         Eigen::Vector2d target_velocity_2d;
         target_velocity_2d << vx, vy;
         Eigen::Vector2d target_linear_velocity_2d;
-        target_linear_velocity_2d << v_yaw * r * cos(target_yaw), v_yaw* r* sin(target_yaw);
+        target_linear_velocity_2d << v_yaw * r * cos(target_yaw), v_yaw * r * sin(target_yaw);
 
         Eigen::Vector2d tangental_velocity_2d = R * (target_velocity_2d + target_linear_velocity_2d);
         double feed_forward_w_radius = -tangental_velocity_2d(1) / distance;
Index: armor_solver/src/kalman_pool/robot.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by lbw on 25-3-13.\n//\n\n#include \"armor_solver/kalman_pool/robot.h\"\n\n#include <ceres/ceres.h>\n#include <angles/angles.h>\n#include <visualization/visualization.h>\n\n#include \"parameter/parameter.h\"\n\n//迭代初始点选取算法\n//#define Algorithm_Rotation_Matrix //基于等长半径计算\n#define Algorithm_Geometry\n// #define Algorithm_Vector\n\nObject::Robot::Robot(const std::string& ID): ObjectBase(ID)\n{\n  dt_ = 0.05;\n  r_avg[0] = 0.26;\n  r_avg[1] = 0.26;\n  r_count = 0;\n  z_c_count = 0.0;\n  z_c_avg = 0.0;\n  first_observe = true;\n  Robot::init();\n}\n\nObject::Robot::~Robot()\n{\n}\n\nvoid Object::Robot::init()\n{\n  observer_ = std::make_unique<Observer>([this]() { return dt_; });\n  Observer::Noise noise;\n  global_node::Parameter->get_parameter(\"robot.q_x\", noise.q_x);\n  global_node::Parameter->get_parameter(\"robot.q_y\", noise.q_y);\n  global_node::Parameter->get_parameter(\"robot.q_z\", noise.q_z);\n  global_node::Parameter->get_parameter(\"robot.r_x\", noise.r_x);\n  global_node::Parameter->get_parameter(\"robot.r_y\", noise.r_y);\n  global_node::Parameter->get_parameter(\"robot.r_z\", noise.r_z);\n\n  global_node::Parameter->get_parameter(\"robot.q_yaw\", noise.q_yaw);\n  global_node::Parameter->get_parameter(\"robot.r_yaw\", noise.r_yaw);\n\n  global_node::Parameter->get_parameter(\"robot.q_sx\", noise.qs_x);\n  global_node::Parameter->get_parameter(\"robot.q_sy\", noise.qs_y);\n  global_node::Parameter->get_parameter(\"robot.q_sz\", noise.qs_z);\n  global_node::Parameter->get_parameter(\"robot.q_syaw\", noise.qs_yaw);\n  global_node::Parameter->get_parameter(\"robot.q_sr\", noise.qs_r);\n  global_node::Parameter->get_parameter(\"robot.q_sdz\", noise.qs_dz);\n  global_node::Parameter->get_parameter(\"robot.rd_x\", noise.rd_x);\n  global_node::Parameter->get_parameter(\"robot.rd_y\", noise.rd_y);\n  global_node::Parameter->get_parameter(\"robot.rd_z\", noise.rd_z);\n  global_node::Parameter->get_parameter(\"robot.rd_r\", noise.rd_r);\n  global_node::Parameter->get_parameter(\"robot.rd_dz\", noise.rd_dz);\n\n  global_node::Parameter->get_parameter(\"robot.q_ro\", noise.q_ro);\n  global_node::Parameter->get_parameter(\"robot.r_ro\", noise.r_ro);\n\n  global_node::Parameter->get_parameter(\"robot.max_match_distance\", max_match_distance_);\n  global_node::Parameter->get_parameter(\"robot.max_match_yaw_diff\", max_match_yaw_diff_);\n  observer_->setNoise(noise);\n  measurement = Eigen::Vector4d(0, 0, 0, 0);\n}\n\nrm_interfaces::msg::Measurement Object::Robot::update(rm_interfaces::msg::Armors& same_num_armors)\n{\n  rm_interfaces::msg::Measurement measurement_msg;\n  ckyf::visualization::CenterMeasure center_measure{};\n  center_measure.isDetect = false;\n  if (first_frame_)\n  {\n    std::cout << \"First Frame\" << std::endl;\n    reset(same_num_armors.header.stamp, same_num_armors.armors[0]);\n    first_observe = false;\n    dt_ = 0.05;\n  }\n  else\n  {\n    rclcpp::Time time = same_num_armors.header.stamp;\n    dt_ = (time - last_time_).seconds();\n    last_time_ = time;\n  }\n\n  auto prediction_yaw = observer_->predictYaw();\n  auto prediction_all = observer_->predictState();\n  target_state = prediction_all;\n\n  auto prediction_armor_position = getArmorPositionFromState(prediction_all);\n\n  auto min_position_diff = DBL_MAX;\n  auto min_yaw_diff = DBL_MAX;\n\n  std::function calc_diff = [&]\n  (const rm_interfaces::msg::Armor& armor, double& yaw_diff, double& position_diff)mutable\n  {\n    auto p = armor.pose.position;\n    Eigen::Vector3d position_vec(p.x, p.y, p.z);\n    position_diff = (position_vec - prediction_armor_position).norm();\n    yaw_diff = orientationToYaw(armor.pose.orientation) - prediction_yaw(6);\n  };\n\n  rm_interfaces::msg::Armor tracked_armor;\n  double measurement_yaw;\n  if (same_num_armors.armors.size() == 1)\n  {\n    tracked_armor = same_num_armors.armors[0];\n    calc_diff(tracked_armor, min_yaw_diff, min_position_diff);\n  }\n  else\n  {\n    std::sort(same_num_armors.armors.begin(), same_num_armors.armors.end(), [&](auto& armor1, auto& armor2) mutable\n    {\n      double position_diff1, position_diff2;\n      double yaw_diff1, yaw_diff2;\n      calc_diff(armor1, yaw_diff1, position_diff1);\n      calc_diff(armor2, yaw_diff2, position_diff2);\n      if (std::abs(position_diff1) < std::abs(position_diff2))\n      {\n        min_position_diff = position_diff1;\n        min_yaw_diff = yaw_diff1;\n        return true;\n      }\n      else\n      {\n        min_position_diff = position_diff2;\n        min_yaw_diff = yaw_diff2;\n        return false;\n      }\n    });\n  }\n\n  tracked_armor = same_num_armors.armors[0];\n  measurement_yaw = orientationToYaw(tracked_armor.pose.orientation);\n  measurement_msg.yaw = measurement_yaw;\n\n  if (same_num_armors.armors.size() >= 2)\n  {\n    rm_interfaces::msg::Armor another_armor = same_num_armors.armors[1];\n    // std::cout << \"update for 2 armors\" << std::endl;\n\n    Eigen::Vector2d center_position(target_state(0), target_state(1));\n    if (armors_to_center(same_num_armors, center_position))\n    {\n      //同时观测两块装甲板\n      Eigen::Vector2d p_armor1(same_num_armors.armors[0].pose.position.x, same_num_armors.armors[0].pose.position.y);\n      Eigen::Vector2d p_armor2(same_num_armors.armors[1].pose.position.x, same_num_armors.armors[1].pose.position.y);\n      // std::cout << p_armor1 << std::endl << p_armor2 << std::endl << \"==============\" << std::endl;\n      double r[2];\n      r[0] = (p_armor1 - center_position).norm();\n      r[1] = (p_armor2 - center_position).norm();\n      // std::cout << \"armor1:\" << p_armor1 << std::endl;\n      // std::cout << \"armor2:\" << p_armor2 << std::endl;\n      // std::cout << \"center:\" << center_position << std::endl;\n      // std::cout << \"r1: \" << r[0] << \", \" << r_avg[0] << \", \" << r_count << std::endl;\n      // std::cout << \"r2: \" << r[1] << \", \" << r_avg[1] << \", \" << r_count << std::endl;\n      // std::cout << \"*******************************\" << std::endl;\n\n      if (r[0] < 0.4 && r[0] > 0.12 && r[1] < 0.4 && r[1] > 0.12)\n      {\n        global_node::Visualization->debug_user.debug1 = r[0];\n        global_node::Visualization->debug_user.debug2 = r[1];\n        if (just_reset)\n        {\n          r_avg[0] = r[0];\n          r_avg[1] = r[1];\n          r_count = 1;\n          just_reset = false;\n        }\n        //判断当前追踪的装甲板 0是低板，1是高板\n        if (same_num_armors.armors[0].pose.position.z > same_num_armors.armors[1].pose.position.z) //armor0是高板\n        {\n          r_avg[0] = (r_avg[0] * r_count + r[1]) / (r_count + 1);\n          r_avg[1] = (r_avg[1] * r_count + r[0]) / (r_count + 1);\n        }\n        else\n        {\n          r_avg[0] = (r_avg[0] * r_count + r[0]) / (r_count + 1);\n          r_avg[1] = (r_avg[1] * r_count + r[1]) / (r_count + 1);\n        }\n        r_count = std::min(r_count + 1, 500.0);\n\n        observer_->setState(target_state);\n\n        center_measure.isDetect = true;\n        center_measure.x = center_position(0);\n        center_measure.y = center_position(1);\n      }\n      else\n      {\n        FYT_ERROR(\"armor_solver\", \"Invalid R Solved\");\n      }\n    }\n    else\n    {\n      FYT_WARN(\"armor_solver\", \"Observe two armors but not the same robot\");\n    }\n  }\n\n  global_node::Visualization->debug_user.yaw_diff = std::abs(min_yaw_diff);\n  global_node::Visualization->debug_user.position_diff = std::abs(min_position_diff);\n  position_diff = min_position_diff;\n  global_node::Visualization->debug_user.debug20 = tracked_armor.yaw_in_camera;\n  if (std::abs(min_yaw_diff) < max_match_yaw_diff_ && min_position_diff < max_match_distance_)\n  {\n    Eigen::Matrix<double, 1, 1> yaw_measurement;\n    yaw_measurement << measurement_yaw;\n    observer_->updateYaw(yaw_measurement, tracked_armor.yaw_in_camera);\n    updateTranslate(tracked_armor, prediction_yaw, measurement_msg);\n  }\n  else\n  {\n    if (std::abs(min_yaw_diff) > max_match_yaw_diff_ && same_num_armors.armors.size() == 1)\n    {\n      FYT_WARN(\"armor_solver\", \"min_yaw_diff:{},max_match_yaw_diff:{}\", min_yaw_diff, max_match_yaw_diff_);\n      FYT_INFO(\"armor_solver\", \"[Observer]Armor Yaw Jumped!\");\n      handleArmorYawJump(tracked_armor);\n    }\n    else if (min_position_diff > max_match_distance_ && std::abs(min_yaw_diff) < max_match_yaw_diff_)\n    {\n      FYT_WARN(\"armor_solver\", \"min_position_diff:{},max_match_distance_:{}\", min_position_diff, max_match_distance_);\n      FYT_WARN(\"armor_solver\", \"[Observer]Armor Position Jumped!\");\n      handleArmorPositionJump(tracked_armor);\n    }\n    else\n    {\n      // reset(same_num_armors.header.stamp, tracked_armor);\n      FYT_ERROR(\"armor_solver\", \"[Observer]Wrong!\");\n      std::cout << \"min_yaw:\" << min_yaw_diff << \" min_position:\" << min_position_diff << std::endl;\n      // observer_->setState(prediction_all);\n    }\n  }\n\n\n  if (target_state(8) < 0.12)\n  {\n    target_state(8) = 0.12;\n    observer_->setState(target_state);\n  }\n  else if (target_state(8) > 0.4)\n  {\n    target_state(8) = 0.4;\n    observer_->setState(target_state);\n  }\n\n  if (target_state(5) > 0.5)\n  {\n    target_state(5) = 0.5;\n    observer_->setState(target_state);\n  }\n  else if (target_state(5) < -0.5)\n  {\n    target_state(5) = -0.5;\n    observer_->setState(target_state);\n  }\n  measurement_msg.x = tracked_armor.pose.position.x;\n  measurement_msg.y = tracked_armor.pose.position.y;\n  measurement_msg.z = tracked_armor.pose.position.z;\n  return measurement_msg;\n}\n\nrm_interfaces::msg::Target Object::Robot::getState()\n{\n  rm_interfaces::msg::Target target;\n  target.header.frame_id = \"odom\";\n  target.header.stamp = last_time_;\n  target.position.x = target_state(0);\n  target.position.y = target_state(1);\n  target.position.z = target_state(2);\n  target.velocity.x = target_state(3);\n  target.velocity.y = target_state(4);\n  target.velocity.z = target_state(5);\n  target.yaw = target_state(6);\n  target.v_yaw = target_state(7);\n  target.radius_1 = target_state(8);\n  target.radius_2 = another_r;\n  target.d_zc = d_zc;\n  target.id = id;\n  target.armors_num = 4;\n  target.position_diff = position_diff;\n  target.d_height = d_height;\n  return target;\n}\n\nrm_interfaces::msg::Target Object::Robot::predict()\n{\n  rclcpp::Time now = global_node::Clock->time();\n  auto duration = now - last_time_;\n  dt_ = duration.seconds();\n  last_time_ = now;\n  target_state = observer_->predictState();\n\n  rm_interfaces::msg::Target target;\n  target.position.x = target_state(0);\n  target.velocity.x = target_state(3);\n  target.acceleration.x = 0;\n  target.position.y = target_state(1);\n  target.velocity.y = target_state(4);\n  target.acceleration.y = 0;\n  target.position.z = target_state(2);\n  target.velocity.z = target_state(5);\n  target.acceleration.y = 0;\n  target.yaw = target_state(6);\n  target.v_yaw = target_state(7);\n  target.radius_1 = target_state(8);\n  target.radius_2 = another_r;\n  target.d_zc = d_zc;\n  target.armors_num = 4;\n  target.position_diff = position_diff;\n  target.d_za = d_za;\n  target.d_height = d_height; //当前kalman的z+d_height ==> 下一块的装甲板height\n  return target;\n}\n\nvoid Object::Robot::reset(const rclcpp::Time& time, const rm_interfaces::msg::Armor& armor)\n{\n  last_time_ = time;\n\n  double xa = armor.pose.position.x;\n  double ya = armor.pose.position.y;\n  double za = armor.pose.position.z;\n  last_yaw_ = 0;\n  double yaw = KalmanCommon::orientationToYaw(armor.pose.orientation);\n  yaw = last_yaw_ + angles::shortest_angular_distance(last_yaw_, yaw);\n  last_yaw_ = yaw;\n\n  // Set initial position at 0.2 m behind the target\n  target_state = Eigen::VectorXd::Zero(Observer::X_A);\n  double r;\n  if (first_observe)\n  {\n    another_r = r = 0.26;\n    just_reset = false;\n  }\n  else\n  {\n    r = r_avg[0];\n    another_r = r_avg[1];\n    just_reset = true;\n  }\n  double xc = xa + r * cos(yaw);\n  double yc = ya + r * sin(yaw);\n  double zc = za;\n  d_za = 0, d_zc = 0;\n  target_state << xc, yc, zc, 0, 0, 0, yaw, 0, r, d_zc;\n\n  observer_->setState(target_state);\n}\n\nvoid Object::Robot::resetFromSensor(const geometry_msgs::msg::Pose& pose)\n{\n  target_state << pose.position.x, 0, pose.position.y, 0, pose.position.z, 0,\n    KalmanCommon::orientationToYaw(pose.orientation), 0, 0.20, d_zc;\n}\n\nEigen::Vector3d Object::Robot::getArmorPositionFromState(const Eigen::VectorXd& x)\n{\n  // Calculate predicted position of the current armor\n  double xc = x(0), yc = x(1), za = x(2) + x(9);\n  double yaw = x(6), r = x(8);\n  double xa = xc - r * cos(yaw);\n  double ya = yc - r * sin(yaw);\n  return Eigen::Vector3d(xa, ya, za);\n}\n\ndouble Object::Robot::orientationToYaw(const geometry_msgs::msg::Quaternion& q)\n{\n  // Get armor yaw\n  tf2::Quaternion tf_q;\n  tf2::fromMsg(q, tf_q);\n  double roll, pitch, yaw;\n  tf2::Matrix3x3(tf_q).getRPY(roll, pitch, yaw);\n  // Make yaw change continuous (-pi~pi to -inf~inf)\n  yaw = last_yaw_ + angles::shortest_angular_distance(last_yaw_, yaw);\n  last_yaw_ = yaw;\n  return yaw;\n}\n\nvoid Object::Robot::handleArmorYawJump(const rm_interfaces::msg::Armor& current_armor)\n{\n  double last_yaw = target_state(6);\n  double yaw = orientationToYaw(current_armor.pose.orientation);\n  // Eigen::Vector3d p(current_armor.pose.position.x, current_armor.pose.position.y, current_armor.pose.position.z);\n  if (abs(yaw - last_yaw) > 0.4)\n  {\n    // Armor angle also jumped, take this case as target spinning\n    target_state(6) = yaw;\n\n    if (std::abs(target_state(2) - current_armor.pose.position.z) > 0.02)\n    {\n      // Only 4 armors has 2 radius and height\n\n      d_za = target_state(2) + d_zc - current_armor.pose.position.z;\n\n      z_c_avg = (z_c_count * z_c_avg + std::abs(d_za)) / (z_c_count + 1);\n      d_za = d_za > 0 ? z_c_avg : -z_c_avg;\n      //判断装甲板的半径对应关系，半径是否需要交换\n\n      if (d_za > 0.01)\n      {\n        target_state(8) = r_avg[0];\n        another_r = r_avg[1];\n      }\n      else\n      {\n        target_state(8) = r_avg[1];\n        another_r = r_avg[0];\n      }\n      global_node::Visualization->debug_user.debug14 = d_za;\n      d_zc = d_zc == 0 ? -d_za : 0;\n      target_state(9) = d_zc;\n\n      d_height = target_state(2) - current_armor.pose.position.z;\n      target_state(2) = current_armor.pose.position.z;\n    }\n    just_reset = false;\n    global_node::Visualization->debug_user.debug16 = d_zc;\n    FYT_DEBUG(\"armor_solver\", \"[Observer]Armor Jump!\");\n  }\n  observer_->setState(target_state);\n}\n\nvoid Object::Robot::handleArmorPositionJump(const rm_interfaces::msg::Armor& current_armor)\n{\n  last_time_ = global_node::Clock->time();\n\n  double xa = current_armor.pose.position.x;\n  double ya = current_armor.pose.position.y;\n  double za = current_armor.pose.position.z;\n  double yaw = KalmanCommon::orientationToYaw(current_armor.pose.orientation);\n  yaw = last_yaw_ + angles::shortest_angular_distance(last_yaw_, yaw);\n  last_yaw_ = yaw;\n\n  // Set initial position at 0.2 m behind the target\n  double r = target_state(8);\n  target_state(0) = xa + r * cos(yaw);\n  target_state(1) = ya + r * sin(yaw);\n  target_state(2) = za - d_zc;\n  target_state(6) = yaw;\n  observer_->setState(target_state);\n}\n\nbool Object::Robot::armors_to_center(const rm_interfaces::msg::Armors& armors_msg, Eigen::Vector2d& center)\n{\n  auto yaw_in_camera1 = armors_msg.armors[0].yaw_in_camera;\n  auto yaw_in_camera2 = armors_msg.armors[1].yaw_in_camera;\n  double yaw1 = orientationToYaw(armors_msg.armors[0].pose.orientation);\n  double yaw2 = orientationToYaw(armors_msg.armors[1].pose.orientation);\n  double x1 = armors_msg.armors[0].pose.position.x, y1 = armors_msg.armors[0].pose.position.y;\n  double x2 = armors_msg.armors[1].pose.position.x, y2 = armors_msg.armors[1].pose.position.y;\n#ifdef Algorithm_Rotation_Matrix\n  const auto& armor1 = armors_msg.armors[0];\n  const auto& armor2 = armors_msg.armors[1];\n  // std::cout << \"yaw1: \" << yaw1 << \" yaw2: \" << yaw2 << \" delta: \" << yaw2 - yaw1 << std::endl;\n  if (abs(yaw1 - yaw2) > 1.8 || abs(yaw2 - yaw1) < 1.4)\n  {\n    return false;\n  }\n\n  //double x1, y1, x2, y2;\n  x1 = armor1.pose.position.x;\n  y1 = armor1.pose.position.y;\n  x2 = armor2.pose.position.x;\n  y2 = armor2.pose.position.y;\n  Eigen::Vector2d p1(x1, y1);\n  Eigen::Vector2d p2(x2, y2);\n  double theta = yaw2 - yaw1;\n\n  Eigen::Matrix2d R;\n  R << cos(theta), -sin(theta),\n    sin(theta), cos(theta);\n\n  auto R_I_inv = (R - Eigen::Matrix2d::Identity()).inverse();\n  center = R_I_inv * (R * p1 - p2);\n\n#endif\n\n#ifdef Algorithm_Geometry\n  Eigen::Vector2d v1(x1, x2);\n  Eigen::Vector2d v2(cos(yaw1) * sin(yaw2), -cos(yaw2) * sin(yaw1));\n  Eigen::Vector2d kalman_center = center;\n  center.x() = (tan(yaw1) * x1 - tan(yaw2) * x2 + y2 - y1) / (tan(yaw1) - tan(yaw2));\n  center.y() = sin(yaw1) == 0 ? center.x() : sin(yaw1) / cos(yaw1) * (center.x() - x1) + y1;\n\n\n#endif\n\n  iteration_solver(center.x(), center.y(), x1, y1, x2, y2, yaw1, yaw2, center);\n  return true;\n}\n\nvoid Object::Robot::updateTranslate(rm_interfaces::msg::Armor& tracked_armor,\n                                    Eigen::MatrixXd position_only_predict_yaw,\n                                    rm_interfaces::msg::Measurement& measurement_msg)\n{\n  const auto& p = tracked_armor.pose.position;\n\n  double r = target_state(8);\n  double yaw = target_state(6);\n  double dz = d_zc; // target_state(9);\n\n  Eigen::Vector3d measured_center = Eigen::Vector3d(p.x + r * cos(yaw), p.y + r * sin(yaw), p.z);\n  observer_->predictTranslate();\n  target_state = observer_->updateTranslate(measured_center, tracked_armor.yaw_in_camera);\n  measurement_msg.x = p.x;\n  measurement_msg.y = p.y;\n  measurement_msg.z = p.z;\n  last_za = p.z;\n\n  global_node::Visualization->debug_user.debug4 = p.x;\n  global_node::Visualization->debug_user.debug5 = -r * cos(yaw) + 2.3;\n  global_node::Visualization->debug_user.debug6 = r * cos(yaw) + p.x;\n  global_node::Visualization->debug_user.debug7 = p.y;\n  global_node::Visualization->debug_user.debug8 = -r * sin(yaw) - 0.1;\n  global_node::Visualization->debug_user.debug9 = r * sin(yaw) + p.y;\n  global_node::Visualization->debug_user.debug10 = p.z;\n  global_node::Visualization->debug_user.debug11 = p.z - dz;\n  global_node::Visualization->debug_user.debug12 = dz;\n  global_node::Visualization->debug_user.debug13 = target_state(2) - dz;\n}\n\nvoid Object::Robot::iteration_solver(double& x, double& y,\n                                     double x1, double y1,\n                                     double x2, double y2,\n                                     double yaw1, double yaw2,\n                                     Eigen::Vector2d kalman_center)\n{\n  double mu_yaw = 0.1; //yaw约束的惩罚系数\n  double mu_center = 10.0; //中心点约束的惩罚系数\n\n  ceres::Problem problem;\n  ceres::CostFunction* cost_for_point1 =\n    new ceres::AutoDiffCostFunction<YawResidual, 1, 1, 1>(\n      new YawResidual(x1, y1, x2, y2, yaw1, yaw2, mu_yaw));\n  problem.AddResidualBlock(cost_for_point1, nullptr, &x, &y);\n\n  ceres::CostFunction* cost_for_kalman =\n    new ceres::AutoDiffCostFunction<CenterResidual, 1, 1, 1>(\n      new CenterResidual(kalman_center.x(), kalman_center.y(), mu_center));\n  problem.AddResidualBlock(cost_for_kalman, nullptr, &x, &y);\n\n  ceres::CostFunction* cost_for_length =\n    new ceres::AutoDiffCostFunction<LengthResidual, 1, 1, 1>(\n      new LengthResidual(x1, y1, x2, y2));\n  problem.AddResidualBlock(cost_for_length, nullptr, &x, &y);\n\n\n  ceres::Solver::Options options;\n  options.linear_solver_type = ceres::DENSE_QR;\n  options.minimizer_progress_to_stdout = false;\n  options.max_num_iterations = 5;\n\n  // 运行优化\n  ceres::Solver::Summary summary;\n  ceres::Solve(options, &problem, &summary);\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/armor_solver/src/kalman_pool/robot.cpp b/armor_solver/src/kalman_pool/robot.cpp
--- a/armor_solver/src/kalman_pool/robot.cpp	(revision 3e365c7f056e39f3bd2d0f8f7b578e414c34e62b)
+++ b/armor_solver/src/kalman_pool/robot.cpp	(date 1766758241709)
@@ -215,8 +215,8 @@
   {
     if (std::abs(min_yaw_diff) > max_match_yaw_diff_ && same_num_armors.armors.size() == 1)
     {
-      FYT_WARN("armor_solver", "min_yaw_diff:{},max_match_yaw_diff:{}", min_yaw_diff, max_match_yaw_diff_);
-      FYT_INFO("armor_solver", "[Observer]Armor Yaw Jumped!");
+      // FYT_WARN("armor_solver", "min_yaw_diff:{},max_match_yaw_diff:{}", min_yaw_diff, max_match_yaw_diff_);
+      // FYT_INFO("armor_solver", "[Observer]Armor Yaw Jumped!");
       handleArmorYawJump(tracked_armor);
     }
     else if (min_position_diff > max_match_distance_ && std::abs(min_yaw_diff) < max_match_yaw_diff_)
